/**
 * Widget Code Generator
 * Generates widget files from workflow state using templates
 */

import type {
  StateManagementApproach,
  WidgetSetting,
  WorkflowState,
} from "../types";
import {
  configTemplate,
  manifestTemplate,
  settingTemplate,
  translationTemplate,
  widgetTemplate,
} from "./templates";

export type TemplateMap = Record<string, string>;

type TokenMap = Record<string, string>;

const replaceTokens = (template: string, tokens: TokenMap) =>
  Object.entries(tokens).reduce(
    (result, [key, value]) => result.split(`{{${key}}}`).join(value),
    template,
  );

const buildSettingsInterface = (settings: WidgetSetting[]) =>
  settings
    .map((setting) => `  ${setting.name || "setting"}: ${setting.type};`)
    .join("\n");

const buildSettingsDefaults = (settings: WidgetSetting[]) =>
  settings
    .map((setting) =>
      `  ${setting.name || "setting"}: ${formatDefaultValue(setting.defaultValue)},`,
    )
    .join("\n");

const formatDefaultValue = (value: string) => {
  if (value.trim() === "") {
    return "\"\"";
  }
  if (!Number.isNaN(Number(value))) {
    return value;
  }
  if (value === "true" || value === "false") {
    return value;
  }
  return `"${value}"`;
};

const buildMapPlaceholder = (hasMapView: boolean) =>
  hasMapView
    ? "<p>Map interaction enabled via JimuMapView.</p>"
    : "";

const buildDataSourcePlaceholder = (hasDataSource: boolean) =>
  hasDataSource
    ? "<p>Data source is configured in settings.</p>"
    : "";

const toComponentName = (name: string) =>
  name
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("") || "Widget";

const resolveStateHook = (stateManagement: StateManagementApproach) => {
  switch (stateManagement) {
    case "Zustand store":
      return "// TODO: Add Zustand store integration";
    case "Redux (jimu-core)":
      return "// TODO: Add jimu-core Redux store integration";
    default:
      return "// TODO: Add local React state";
  }
};

export const generateWidget = (state: WorkflowState): TemplateMap => {
  const { widgetBrief, widgetPRD, widgetArchitecture } = state;
  const hasSettings = widgetPRD.settingsConfig.hasSettings;
  const hasMapView = widgetArchitecture.jimuIntegration.usesJimuMapView;
  const hasDataSource = widgetArchitecture.jimuIntegration.usesDataSourceComponent;

  const requiredJimuModules =
    widgetArchitecture.dependencies.requiredJimuModules;
  const jimuDependencies =
    requiredJimuModules.length > 0
      ? `"${requiredJimuModules.join('", "')}"`
      : "";

  const settingsInterface = buildSettingsInterface(
    widgetPRD.settingsConfig.settings,
  );
  const settingsDefaults = buildSettingsDefaults(
    widgetPRD.settingsConfig.settings,
  );

  const tokens: TokenMap = {
    WIDGET_NAME: widgetBrief.name || "generated-widget",
    WIDGET_LABEL: widgetBrief.displayLabel || "Generated Widget",
    WIDGET_DESCRIPTION:
      widgetBrief.description || "Generated by the BMAD workflow.",
    JIMU_DEPENDENCIES: jimuDependencies,
    HAS_SETTINGS: hasSettings ? "true" : "false",
    SETTINGS_INTERFACE: settingsInterface || "  ",
    SETTINGS_DEFAULTS: settingsDefaults || "  ",
    COMPONENT_NAME:
      widgetArchitecture.mainComponentName ||
      toComponentName(widgetBrief.name || widgetBrief.displayLabel || "Widget"),
    JIMU_ARCGIS_IMPORT: hasMapView
      ? 'import { JimuMapViewComponent } from "jimu-arcgis";'
      : "",
    MAP_VIEW_PLACEHOLDER: buildMapPlaceholder(hasMapView),
    DATA_SOURCE_PLACEHOLDER: buildDataSourcePlaceholder(hasDataSource),
  };

  const widgetBody = replaceTokens(widgetTemplate, {
    ...tokens,
    MAP_VIEW_PLACEHOLDER: buildMapPlaceholder(hasMapView),
    DATA_SOURCE_PLACEHOLDER: buildDataSourcePlaceholder(hasDataSource),
  });

  const widgetStateComment = resolveStateHook(widgetArchitecture.stateManagement);
  const widgetContent = widgetBody.replace(
    "</div>",
    `\n      <pre>${widgetStateComment}</pre>\n    </div>`,
  );

  const files: TemplateMap = {
    "manifest.json": replaceTokens(manifestTemplate, tokens),
    "config.ts": replaceTokens(configTemplate, tokens),
    "runtime/widget.tsx": widgetContent,
    "translations/default.ts": replaceTokens(translationTemplate, tokens),
  };

  if (hasSettings) {
    files["setting/setting.tsx"] = replaceTokens(settingTemplate, tokens);
  }

  return files;
};
